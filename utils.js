const Utils = {
    // Schema Definition
    createExportData: (cookies, localStorageData, sessionStorageData, origin) => {
        return {
            version: "1.0",
            source: "DevToolsStorageManager",
            createdAt: new Date().toISOString(),
            origin: origin,
            data: {
                cookies: cookies || [],
                localStorage: localStorageData || {},
                sessionStorage: sessionStorageData || {}
            }
        };
    },

    // --- Export Functions ---

    exportToJSON: (data) => {
        return JSON.stringify(data, null, 2);
    },

    exportToHeaderString: (cookies) => {
        return cookies.map(c => `${c.name}=${c.value}`).join('; ');
    },

    exportToNetscape: (cookies) => {
        let content = "# Netscape HTTP Cookie File\n# This file is generated by DevTools Storage Manager\n\n";
        cookies.forEach(c => {
            const domain = c.domain.startsWith('.') ? c.domain : '.' + c.domain;
            const includeSubdomains = domain.startsWith('.') ? 'TRUE' : 'FALSE';
            const path = c.path;
            const secure = c.secure ? 'TRUE' : 'FALSE';
            const expiry = c.expirationDate ? Math.floor(c.expirationDate) : 0;
            const name = c.name;
            const value = c.value;
            content += `${domain}\t${includeSubdomains}\t${path}\t${secure}\t${expiry}\t${name}\t${value}\n`;
        });
        return content;
    },

    // --- Import Functions ---

    importFromJSON: (jsonString) => {
        try {
            const parsed = JSON.parse(jsonString);
            
            // Case 1: Standard Schema { data: { ... } }
            if (parsed.data && !Array.isArray(parsed)) {
                return parsed.data;
            }

            // Case 2: Simple Array [ {name, value}, ... ]
            // We need to guess what kind of data it is.
            // Since we can't easily distinguish between cookies and storage just by name/value,
            // we might need to return a generic structure or assume based on content.
            // However, the import logic in panel.js currently handles:
            // - cookies array
            // - storage object
            
            // If it's an array, we'll assume it's cookies IF it has domain/path, 
            // OR we treat it as the "Active Tab" target type in a smarter way?
            // Actually, the Utils.importFromJSON returns a structure: { cookies: [], localStorage: {}, sessionStorage: {} }
            
            if (Array.isArray(parsed)) {
                // Let's check the first item to guess
                const first = parsed[0];
                if (!first) return { cookies: [], localStorage: {}, sessionStorage: {} };

                // If it looks like a cookie (has domain/path/secure etc), treat as cookie
                if (first.domain || first.path) {
                    return { cookies: parsed, localStorage: {}, sessionStorage: {} };
                }
                
                // Otherwise, it's just Key-Value pairs.
                // We don't know if it's Local or Session storage.
                // Strategy: Put it in a special "genericKV" field and let the UI decide?
                // OR: Just put it in BOTH or assume LocalStorage (most common).
                
                // Better approach: Convert array [{name: "k", value: "v"}] to Object {"k": "v"}
                const storageObj = {};
                parsed.forEach(item => {
                    // Support both 'name' and 'key' properties for flexibility
                    const key = item.name || item.key;
                    if (key) {
                        // Value can be string or object (if user provided JSON object directly)
                        storageObj[key] = item.value !== undefined ? item.value : "";
                    }
                });
                
                // Return as localStorage by default as it's the safest bet for generic KV
                return { cookies: [], localStorage: storageObj, sessionStorage: {} };
            }

            return null;
        } catch (e) {
            console.error("Import JSON failed", e);
            return null;
        }
    },

    parseHeaderString: (headerString, currentDomain) => {
        const cookies = [];
        const parts = headerString.split(';');
        parts.forEach(part => {
            const [name, ...valParts] = part.trim().split('=');
            if (name) {
                cookies.push({
                    domain: currentDomain,
                    name: name,
                    value: valParts.join('='),
                    path: '/',
                    secure: false,
                    httpOnly: false
                });
            }
        });
        return { cookies, localStorage: {}, sessionStorage: {} };
    },

    parseNetscape: (netscapeString) => {
        const cookies = [];
        const lines = netscapeString.split('\n');
        lines.forEach(line => {
            if (line.startsWith('#') || !line.trim()) return;
            const parts = line.split('\t');
            if (parts.length >= 7) {
                cookies.push({
                    domain: parts[0],
                    // includeSubdomains: parts[1] === 'TRUE',
                    path: parts[2],
                    secure: parts[3] === 'TRUE',
                    expirationDate: parseInt(parts[4]),
                    name: parts[5],
                    value: parts[6]
                });
            }
        });
        return { cookies, localStorage: {}, sessionStorage: {} };
    }
};
